\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amsmath}
\graphicspath{{png/}}
%opening
\title{Algorithmique avancée : Rapport du projet}
\author{FOURNIER Benoit, THIERRY Constance}

\begin{document}

\maketitle

\begin{figure}[b]
\begin{center}
\includegraphics[scale=1]{Enssat.png}
\end{center}
\end{figure}

\thispagestyle{empty}

\newpage
\null
\thispagestyle{empty}
\newpage

\tableofcontents

\hfill

\listoffigures

\newpage
\null
\thispagestyle{empty}
\newpage

\section{Introduction}

La triangularisation de polygone est un problème ()?) 
utilisé dans la modélisation 2d et 3d et permet de subdiviser un polygone en un ensemble de triangle.
Nous nous interessons ici au sous-cas des polygone convexe avec pour contrainte une (distance de traingularisation) la plus faible possible.
L'objectif de cette etude et de comparer différentes solutions algorithmque pour résoudre ce problème.
Nous commencerons par exposer les methodes dite d'essai successif puis de programmation dynamqieu et enfin un algoritme glouton.
Nous comparerons ensuiste leur performances et nous concluerons sur ces différentes méthodes


\section{Etude préliminaire}

\subsection{Nombre de cordes distinctes dans un polygone à \emph{n} sommets}

\paragraph{Propriété :}
Appelons \emph{NbCordesDistinctes(n)} le nombre de cordes distinctes que l'on peut dénombrer dans un polygone à \emph{n} sommets.
Nous avons alors :

\begin{equation} 
\begin{array}{r @{=} l}
NbCordesDistinctes(n) \ & \ 2(n-3) + \sum_{i=0}^{n-4} i \\
		      & \ 2(n-3) + \frac{(n-4)(n-3)}{2} \\
		      & \ \frac{n(n-3)}{2}
\end{array} 
\end{equation}


\begin{proof}
Pour \(n = 4\) nous avons : \(NbCordesDistinctes(4)=2 \) la propriété est vérifiée. \\
Admetons la propriété vrais à un rang \emph{n} et démontrons la au rang \emph{n+1}. \\
Nous avons :\\
\[NbCordesDistinctes(n+1) = (NombreDeNouvellesCordes) + NbCordesDistinctes(n)\]
En effet, le résultat du problème au rang \emph{n+1} est égal à celui du rang \emph{n} auquel on ajoute les nouvelles cordes apparues.
Ce nombre de nouvelles cordes est égale à \(n - 2 + 1 \) car lorsque l'on considère un sommet supplémentaire, celui-ci peut ce lier aux n anciens sommets.
On lui retire les deux sommets qui lui sont adjacents, et on rajoute une liaison entre ces deux sommets adjacents.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=1]{dem1.png}
\caption{Schéma explicatif du nombre de cordes distinctes d'un polygone}
\end{center}
\end{figure}

\[
\begin{array}{r @{=} l}
NbCordesDistinctes(n+1) \ & \ n -  2 + 1 + NbCordesDistinctes(n) \\
			  & \ n - 1 + \frac{n(n-3)}{2} \\
			  & \ \frac{{n^2}-n-2}{2} \\
			  & \ \frac{(n+1)(n-2)}{2} \\
\end{array}
\]
Ce qui achève la récurrence.	
\end{proof}


\subsection{Nombre de cordes pour les triangulation d'un polygone à \emph{n} sommets}

\paragraph{Propriété :}  
Appelons \emph{NbCordesTriang(n)} le nombre de cordes présentent dans une triangulation d'un polygone à \emph{n} sommets.
Toutes les triangulations d'un polygone à \emph{n} sommets comportent le même nombre de cordes \emph{NbCordesTriang(n)}.
De plus nous avons :
\begin{equation} 
NbCordesTriang(n) = n-3
\end{equation}

\begin{proof}
Pour \(n = 4\) nous avons : \(NbCordesTriang(4) = 1 \) la propriété est vérifiée. \\
%TODO : ajouter trop beaux shéma
Admetons la propriété vrais à un rang \emph{n} et démontrons la au rang \emph{n+1}. \\
Considerons un polygone à \emph{n+1} sommets, en traçant une	int;
	int increment = 2; corde entre les sommets \emph{i} et \emph{i+2} on génère un sous polygone de taille \emph{n}.
Le nombre de cordes d'une triangulation d'un polygone de taille \emph{n+1} est donc égale au nombre de cordes du sous polygone de taille \emph{n} au quel on ajoute une corde.
Nous avons :\\
\[
\begin{array}{r @{=} l}
NbCordesTriang(n+1) \ & \  1 corde + NbCordesTriang(n) \\
			  & \ 1 + (n-3) \\
			  & \ (n+1) - 3
\end{array}
\]
Ce qui achève la récurrence.
\end{proof}





\section{Essais successifs}

\section{Programmation dynamique}

\subsection{Formule de récurrence}



On appelera t la taille du sous-problème débutant au sommet \(s_i\), on défini ainsi le sous problème \(T_{i,t}\).
Pour résoudre le sous problème \(T_{i,t}\) de triangulation d'un polygone par Programmation dynamique nous considererons 3 cas:

\begin{itemize}
 \item Cas 1 : on trace une corde entre les sommets \(s_i\) et \(s_{i+t-2}\), puis l'on résoud le problème \(T_{i,t-1}\).
 \item Cas 2 : on trace une corde entre \(s_{i+1}\) et \(s_{i+t-1}\) puis l'on résoud le problème \(T_{i+1,t-1}\).
 \item Cas 3 : on considère un entier \emph{k} compris entre 2 et \emph{t-k}. On trace deux cordes, une entre \(s_{i}\) et \(s_{i+k}\) et une autre entre \(s_{i+k}\) et \(s_{i+t-1}\).
 Puis l'on résoud les sous problèmes \(T_{i,k+1}\) et \(T_{i+k,t-k}\).
\end{itemize}

On déduit de ces 3 cas la formule de récurrence suivante pour un polygone convexe de taille n: 

\begin{equation} 
T_{i,n} = min 
\begin{pmatrix} 
 longueur(s_i, s_{i+t-2}) + T_{i,n-1} \\
  longueur(s_{i+1}, s_{i+t-1}) + T_{i+1,n-1} \\
  longueur(s_i, s_{i+k}) + longueur(s_{i+k}, s_{i+t-1}) + T_{i,k+1} + T_{i,n-k}
\end{pmatrix}               
\end{equation}

Nous calculons ici la longueur d'une corde entre les sommets \(s_i\) et \(s_j\) grace à la fonction \( longueur(s_i, s_j) \). 

\subsection{Algorithme}

  
\begin{tabbing}
\hspace{0.5cm} \= \hspace{0.5cm}  \= \hspace{0.5cm} \= \hspace{0.5cm} \= \kill

procédure soldynamique(ent n, point poly[], corde2 solution[]);
var piou tabSousPoly[n-2][n-2];
var ent i,j,k,l,t,x,y, x1, y1,  temp1, temp2, tempNb;
var increment <- 2;
var ent NbSommets <- 4; //Correspond au nombre de sommets du sous-polygone (au minimum 4)
var ent ArraySize;
var ent  nbCordeAjout;	
var ent nbCordesArray1, nbCordesArray2 = 0;
var ent sommeCorde_min;
var ent sommeCorde_2 ;

\textit{//Initialisation de la première diagonale de tabSousPoly}\\
pour i allant de 0 à n-2 faire\\
  \> création de la corde c entre les sommets \(s_i\) et \(s_{i+2}\) \\
  \> tab_sous_poly[i][i].somme_corde <- c.lon; \\
  \> \textit{//On ne regarde qu'une seule corde à cette étape} \\
  \> tabSousPoly[i][i].nbCorde <- 1; \\
  \> tabSousPoly[i][i].tabCorde[0] <- c ;
finpour\\
\\
\textit{//Boucle principale pour remplir le tableau tabSousPoly }\\
pour j de 1 à n-3 faire\\
    \> increment <- increment +1;\\ 
    \> pour i allant de 0 à (n-j-2) faire\\
        \> \> t <- j+i\\
	\> \> création de la corde c entre les sommets \(s_i\) et \(s_{i+increment}\) \\
	\> \> \textit{//On utilise les variables x et y pour garder en mémoire la meilleure case du tableau }\\  
	\> \> \textit{//Cas 1} \\
	\> \> sommeCordeMin = longueur(s_i, s_{i+t-2}) + T_{i,n-1} + c.lon; \\
	\> \> enregister case
	\> \> \textit{//Cas 2} \\
	\> \> sommeCorde2 <- longueur(s_{i+1}, s_{i+t-1}) + T_{i+1,n-1} + c.lon; \\
	\> \> si sommeCorde2 < sommeCordeMin alors \\
	  \> \> \> x<-i+1; \\
	  \> \> \> y<-t; \\
	\> \> fin si; \\
	\> \> nbCordeAjout <- tab_sous_poly[x][y].nb_corde; \\
	\> \> nbCordesArray1 <- nbCordeAjout; \\
	\> \> \textit{//Cas 3} \\
	\> \> si NbSommets >= 5 faire \\
	  \> \> \> pour k allant de 2 à NbSommets-3 faire \\
	  \> \> \> \>  sommeCorde2 <- longueur(s_i, s_{i+k}) + longueur(s_{i+k}, s_{i+t-1}) + T_{i,k+1} + T_{i,n-k}

  
finpour\\
\end{tabbing}
 
\subsection{Compléxité spatiale et temporelle}
On utilise une structure tabulaire \((n-2)*(n-2)\) que l'on remplie diagonale par diagonale.
%TODO : ajouter schéma tableau

\subsection{Améliorations possibles}

\section{Algorithme glouton}


\subsection{Principe algorithmique}

On réduit le problème du choix des cordes au seules cordes extérieures, ce qui revient a choisir la plus courte et ré-iterer sur le sous polygone intérieur ainsi créer.

On s'attend raisonablement à trouver une triangularisation de coût faible, sans pour autant avoir la certitude que celle ci est la plus optimale.

\subsection{Mise en oeuvre}
 

On dispose d'un ensemble « extérieur » contenant les points constituant le polygone en cour de triangularisation.
On dispose d'un tableau de solution où inscrire les cordes
On dispose d'un tableu des points ordonné (de cardinal n)
On dispose d'un fonction "coutcorde(corde c)" qui renvoie la longueur d'une corde
 
 
 
\begin{tabbing}
\hspace{0.5cm} \= \hspace{0.5cm}  \= \hspace{0.5cm} \= \hspace{0.5cm} \= \kill
 
\begin{tabbing}
\hspace{0.5cm} \= \hspace{0.5cm}  \= \hspace{0.5cm} \= \hspace{0.5cm} \= \kill


\textit{//initialisation de Exterieur}\\
pour i de 0 à n\\
faire\\
\> Ajouter P[i] à Exterieur\\
finpour\\
\\
\textit{//Boucle principale pour remplir le tableau de solution}\\
pour k de 1 à n-3\\\> \> \textit{//Cas 1} \\
faire\\
    \> min:= $+\infty$ \\ 
    \> pour i de 0 à n\\
    \> faire\\
        \> \> si P[i] est dans Exterieur\\
        \> \> alors\\KH
            \> \> \> c:=corde excluant P[i]\\
            \> \> \> si coutcorde(c)<min\\
            \> \> \> alors\\
                \> \> \> \> min:=coutcorde(c)\\
                \> \> \> \> indice:=i\\
                \> \> \> \> solution[k]:=c\\
            \> \> \> finsi\\
        \> \> finsi\\
    \> finpour\\
    \> Retirer P[indice] de Exterieur\\
finpour\\
\end{tabbing}

Cet algorithme a une complexité en $O(n2)$ (en pratique $O(n2log(n)$ pour la recher de de la corde excluant P[i] complexité du a notre impléméentation) ce qui est ? Comparé au algorithme précedemet étudié.
Néanmoins cette algorithme ne garantie pas l'exactitude de la solution, mais seulement une approximation.
Nous verrons donc comment qualifer cette approximation au vu du jeu d'essai.


\section{Comparaison}

\section{Conclusion}


\end{document}
