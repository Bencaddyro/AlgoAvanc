\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amsmath}
\graphicspath{{png/}}
%opening
\title{Algorithmique avancée : Rapport du projet}
\author{FOURNIER Benoit, THIERRY Constance}

\begin{document}

\maketitle

\begin{figure}[b]
\begin{center}
\includegraphics[scale=1]{Enssat.png}
\end{center}
\end{figure}

\thispagestyle{empty}

\newpage
\null
\thispagestyle{empty}
\newpage

\tableofcontents

\hfill

\listoffigures

\newpage
\null
\thispagestyle{empty}
\newpage

\section{Introduction}

La triangularisation de polygone est un problème de géométrie visant à subdiviser un polygone en triangle.
Nous nous interessons ici au sous-cas des polygones convexes avec contrainte d'optimalité sur les cordes.
La somme de toutes les cordes composant la triangularisation doit être minimale.
L'objectif de cette étude et de comparer différentes solutions algorithmique pour résoudre ce problème.
Nous commencerons par exposer les méthodes d'essai successif puis de programmation dynamique et enfin un algorithme glouton.
Nous comparerons ensuite leur performances et nous concluerons sur ces différentes méthodes


\section{Étude préliminaire}

\subsection{Nombre de cordes distinctes dans un polygone à \emph{n} sommets}

\paragraph{Propriété :}
Appelons \emph{NbCordesDistinctes(n)} le nombre de cordes distinctes que l'on peut dénombrer dans un polygone à \emph{n} sommets.
Nous avons alors :

\begin{equation} 
\begin{array}{r @{=} l}
NbCordesDistinctes(n) \ & \ 2(n-3) + \sum_{i=0}^{n-4} i \\
		      & \ 2(n-3) + \frac{(n-4)(n-3)}{2} \\
		      & \ \frac{n(n-3)}{2}
\end{array} 
\end{equation}


\begin{proof}
Pour \(n = 4\) nous avons : \(NbCordesDistinctes(4)=2 \) la propriété est vérifiée. \\
Admetons la propriété vrais à un rang \emph{n} et démontrons la au rang \emph{n+1}. \\
Nous avons :\\
\[NbCordesDistinctes(n+1) = (NombreDeNouvellesCordes) + NbCordesDistinctes(n)\]
En effet, le résultat du problème au rang \emph{n+1} est égal à celui du rang \emph{n} auquel on ajoute les nouvelles cordes apparues.
Ce nombre de nouvelles cordes est égale à \(n - 2 + 1 \) car lorsque l'on considère un sommet supplémentaire, celui-ci peut ce lier aux n anciens sommets.
On lui retire les deux sommets qui lui sont adjacents, et on rajoute une liaison entre ces deux sommets adjacents.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=1]{dem1.png}
\caption{Schéma explicatif du nombre de cordes distinctes d'un polygone}
\end{center}
\end{figure}

\[
\begin{array}{r @{=} l}
NbCordesDistinctes(n+1) \ & \ n -  2 + 1 + NbCordesDistinctes(n) \\
			  & \ n - 1 + \frac{n(n-3)}{2} \\
			  & \ \frac{{n^2}-n-2}{2} \\
			  & \ \frac{(n+1)(n-2)}{2} \\
\end{array}
\]
Ce qui achève la récurrence.	
\end{proof}


\subsection{Nombre de cordes pour les triangulations d'un polygone à \emph{n} sommets}

\paragraph{Propriété :}  
Appelons \emph{NbCordesTriang(n)} le nombre de cordes présentent dans une triangulation d'un polygone à \emph{n} sommets.
Toutes les triangulations d'un polygone à \emph{n} sommets comportent le même nombre de cordes \emph{NbCordesTriang(n)}.
De plus nous avons :
\begin{equation} 
NbCordesTriang(n) = n-3
\end{equation}

\begin{proof}
Pour \(n = 4\) nous avons : \(NbCordesTriang(4) = 1 \) la propriété est vérifiée. \\
%TODO : ajouter trop beaux shéma
Admetons la propriété vrais à un rang \emph{n} et démontrons la au rang \emph{n+1}. \\
Considérons un polygone à \emph{n+1} sommets, en traçant une corde entre les sommets \emph{i} et \emph{i+2} on génère un sous polygone de taille \emph{n}.
Le nombre de cordes d'une triangulation d'un polygone de taille \emph{n+1} est donc égale au nombre de cordes du sous polygone de taille \emph{n} au quel on ajoute une corde.
Nous avons :\\
\[
\begin{array}{r @{=} l}
NbCordesTriang(n+1) \ & \  1 corde + NbCordesTriang(n) \\
			  & \ 1 + (n-3) \\
			  & \ (n+1) - 3
\end{array}
\]
Ce qui achève la récurrence.
\end{proof}



\section{Essais successifs}


\subsection{Fonction annexe : validecorde()}


Nous utiliserons pour la méthode d'essai successif une fonction \emph{validecorde()} nous permettant de savoir si une corde est valide, c'est à dire qu'elle ne coupe pas une autre corde déjà traçée.
Ce problème peut se réduire à savoir si une corde en coupe une autre, si la corde donnée ne coupe aucune autre corde déjà présente alors elle est valide.
Notons \emph{c(A,B)} la corde de sommet \emph{A,B} avec $A<B$ (les sommets étant numéroté et ordonnés).
Soit \emph{c(A,B)} la corde déjà tracé et \emph{c(i,j)} la corde testée.
Intéressons nous à la reconnaissance du cas ou la corde est valide, soit \emph{s(i,j)} est « au dessus » soit elle est en « dessous ».
Ce qui donne $a<=i et j<=b$ (cas au dessous) ou $i<=a et j>=b$ (au dessus).
Dans les autres cas les cordes se coupent.
Il faut également distinguer le cas ou \emph{c(i,j)} est confondus avec \emph{c(A,B)}.
 

\subsection{Première méthode}

On se place dans une stratégie d'essai successif avec pour choix à l'étape i de prendre une corde valide issue de \emph{Si} où bien de ne rien prendre.
Cette méthode n'est cependant pas très efficace et donneras souvent plusieur fois la même trinagularisation.
La corde \emph{c(A,B)} pourra en effet être retenue au passage par l'étape \emph{A} mais aussi au passage par l'étape \emph{B}.
L'exemple le pus simple pour illustrer cela est celui du quadrilatère,il ne possède que 2 triangulation possible, pourtant cette méthode fourniras 4 solutions.

De plus cette méthode ne permet pas de trouver toutes les trinagulations, prenons un polygone à 8 cotés.
La triangulation (1,3),(3,5),(5,7),(7,1),(1,5) ne pourras jamais être construite, en effet ces 5 cordes n'impliquent que 4 points.
Plus généralement s'il y a plus de corde dans la triangulations que de sommet impliqués alors elle ne peut être trouvée.


\subsection{}
 
Principe Algorithmique

 

Nous choisierons a l'étape i la corde la iéme corde de la solution (tableau de solution de taille n-3)

a cette etape i on pourras choisir une corde valide dans l'ensemble des cordes du polygone non jamais pu d éja faire partie de la solution (pour éviter les doublon)

 

 
\section{Programmation dynamique}

\subsection{Formule de récurrence}



On appelera t la taille du sous-problème débutant au sommet \(s_i\), on défini ainsi le sous problème \(T_{i,t}\).
Pour résoudre le sous problème \(T_{i,t}\) de triangulation d'un polygone par Programmation dynamique nous considererons 3 cas:

\begin{itemize}
 \item Cas 1 : on trace une corde entre les sommets \(s_i\) et \(s_{i+t-2}\), puis l'on résoud le problème \(T_{i,t-1}\).
 \item Cas 2 : on trace une corde entre \(s_{i+1}\) et \(s_{i+t-1}\) puis l'on résoud le problème \(T_{i+1,t-1}\).
 \item Cas 3 : on considère un entier \emph{k} compris entre 2 et \emph{t-k}. On trace deux cordes, une entre \(s_{i}\) et \(s_{i+k}\) et une autre entre \(s_{i+k}\) et \(s_{i+t-1}\).
 Puis l'on résoud les sous problèmes \(T_{i,k+1}\) et \(T_{i+k,t-k}\).
\end{itemize}

On déduit de ces 3 cas la formule de récurrence suivante pour un polygone convexe de taille n: 

\begin{equation} 
T_{i,n} = min 
\begin{pmatrix} 
 longueur(s_i, s_{i+t-2}) + T_{i,n-1} \\
  longueur(s_{i+1}, s_{i+t-1}) + T_{i+1,n-1} \\
  longueur(s_i, s_{i+k}) + longueur(s_{i+k}, s_{i+t-1}) + T_{i,k+1} + T_{i,n-k}
\end{pmatrix}               
\end{equation}

Nous calculons ici la longueur d'une corde entre les sommets \(s_i\) et \(s_j\) grace à la fonction \( longueur(s_i, s_j) \). 

\subsection{Algorithme}

 
 
\subsection{Compléxité spatiale et temporelle}
On utilise une structure tabulaire $(n-2)*(n-2)$ que l'on remplie diagonale par diagonale.
%TODO : ajouter schéma tableau


 
 

\subsection{Algorithme}

\subsection{Compléxité spatiale et temporelle}

\subsection{Améliorations possibles}

\section{Algorithme glouton}


\subsection{Principe algorithmique}

On réduit le problème du choix des cordes au seules cordes extérieures, ce qui revient a choisir la plus courte et ré-iterer sur le sous polygone intérieur ainsi créer.

On s'attend raisonablement à trouver une triangularisation de coût faible, sans pour autant avoir la certitude que celle ci est la plus optimale.

\subsection{Mise en oeuvre}
 

On dispose d'un ensemble « extérieur » contenant les points constituant le polygone en cour de triangularisation.
On dispose d'un tableau de solution où inscrire les cordes
On dispose d'un tableu des points ordonné (de cardinal n)
On dispose d'un fonction "coutcorde(corde c)" qui renvoie la longueur d'une corde
 
 
 
\begin{tabbing}
\hspace{0.5cm} \= \hspace{0.5cm}  \= \hspace{0.5cm} \= \hspace{0.5cm} \= \kill


\textit{//initialisation de Exterieur}\\
pour i de 0 à n\\
faire\\
\> Ajouter P[i] à Exterieur\\
finpour\\
\\
\textit{//Boucle principale pour remplir le tableau de solution}\\
pour k de 1 à n-3\\
faire\\
    \> min:= $+\infty$ \\ 
    \> pour i de 0 à n\\
    \> faire\\
        \> \> si P[i] est dans Exterieur\\
        \> \> alors\\
            \> \> \> c:=corde excluant P[i]\\
            \> \> \> si coutcorde(c)<min\\
            \> \> \> alors\\
                \> \> \> \> min:=coutcorde(c)\\
                \> \> \> \> indice:=i\\
                \> \> \> \> solution[k]:=c\\
            \> \> \> finsi\\
        \> \> finsi\\
    \> finpour\\
    \> Retirer P[indice] de Exterieur\\
finpour\\
\end{tabbing}
 

Cet algorithme à une complexité en $O(n^2)$ (en pratique $O(n^2log(n^2)$ pour la recherche de la corde excluant P[i], complexité dù à notre implémentation).
Cette complexité est ? comparé au algorithme précedement étudié.
Néanmoins cette algorithme ne garantie pas l'exactitude de la solution, mais seulement une approximation.
Nous verrons donc comment qualifer cette approximation au vu du jeu d'essai.


\section{Comparaison}

\section{Conclusion}


\end{document}
